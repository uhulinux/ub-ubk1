diff -Naur vdr-plugin-softhddevice-0.6.1rc1/audio.c git/audio.c
--- vdr-plugin-softhddevice-0.6.1rc1/audio.c	2013-09-30 20:54:27.000000000 +0200
+++ git/audio.c	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file audio.c		@brief Audio module
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 6ca3df1ac67eb1d835a1b6a3cbbaea5f2cb98f02 $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -88,7 +88,7 @@
 #endif
 #endif
 
-#include <alsa/iatomic.h>		// portable atomic_t
+#include "iatomic.h"			// portable atomic_t
 
 #include "ringbuffer.h"
 #include "misc.h"
@@ -123,6 +123,8 @@
 //----------------------------------------------------------------------------
 
 char AudioAlsaDriverBroken;		///< disable broken driver message
+char AudioAlsaNoCloseOpen;		///< disable alsa close/open fix
+char AudioAlsaCloseOpenDelay;		///< enable alsa close/open delay fix
 
 static const char *AudioModuleName;	///< which audio module to use
 
@@ -130,6 +132,7 @@
 static const AudioModule *AudioUsedModule = &NoopModule;
 static const char *AudioPCMDevice;	///< PCM device name
 static const char *AudioPassthroughDevice;	///< Passthrough device name
+static char AudioAppendAES;		///< flag automatic append AES
 static const char *AudioMixerDevice;	///< mixer device name
 static const char *AudioMixerChannel;	///< mixer channel name
 static char AudioDoingInit;		///> flag in init, reduce error
@@ -1005,6 +1008,26 @@
 	Info(_("audio/alsa: using %sdevice '%s'\n"),
 	    passthrough ? "pass-through " : "", device);
     }
+    //
+    // for AC3 pass-through try to set the non-audio bit, use AES0=6
+    //
+    if (passthrough && AudioAppendAES) {
+#if 0
+	// FIXME: not yet finished
+	char *buf;
+	const char *s;
+	int n;
+
+	n = strlen(device);
+	buf = alloca(n + sizeof(":AES0=6") + 1);
+	strcpy(buf, device);
+	if (!(s = strchr(buf, ':'))) {
+	    // no alsa parameters
+	    strcpy(buf + n, ":AES=6");
+	}
+	Debug(3, "audio/alsa: try '%s'\n", buf);
+#endif
+    }
     // open none blocking; if device is already used, we don't want wait
     if ((err =
 	    snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK,
@@ -1189,13 +1212,17 @@
 	// FIXME: if open fails for fe. pass-through, we never recover
 	return -1;
     }
-    if (1) {				// close+open to fix HDMI no sound bug
+    if (!AudioAlsaNoCloseOpen) {	// close+open to fix HDMI no sound bug
 	snd_pcm_t *handle;
 
 	handle = AlsaPCMHandle;
 	// FIXME: need lock
 	AlsaPCMHandle = NULL;		// other threads should check handle
 	snd_pcm_close(handle);
+	if (AudioAlsaCloseOpenDelay) {
+	    usleep(50 * 1000);		// 50ms delay for alsa recovery
+	}
+	// FIXME: can use multiple retries
 	if (!(handle = AlsaOpenPCM(passthrough))) {
 	    return -1;
 	}
@@ -2043,25 +2070,27 @@
 	    int read;
 	    int flush;
 	    int err;
+	    int i;
 
 	    // look if there is a flush command in the queue
 	    flush = 0;
 	    filled = atomic_read(&AudioRingFilled);
 	    read = AudioRingRead;
-	    while (filled--) {
+	    i = filled;
+	    while (i--) {
 		read = (read + 1) % AUDIO_RING_MAX;
 		if (AudioRing[read].FlushBuffers) {
 		    AudioRing[read].FlushBuffers = 0;
 		    AudioRingRead = read;
-		    atomic_set(&AudioRingFilled, filled);
 		    // handle all flush in queue
-		    flush = 1;
+		    flush = filled - i;
 		}
 	    }
 
 	    if (flush) {
-		Debug(3, "audio: flush\n");
+		Debug(3, "audio: flush %d ring buffer(s)\n", flush);
 		AudioUsedModule->FlushBuffers();
+		atomic_sub(flush, &AudioRingFilled);
 		if (AudioNextRing()) {
 		    Debug(3, "audio: break after flush\n");
 		    break;
@@ -2421,8 +2450,23 @@
     int old;
     int i;
 
+    if (atomic_read(&AudioRingFilled) >= AUDIO_RING_MAX) {
+	// wait for space in ring buffer, should never happen
+	for (i = 0; i < 24 * 2; ++i) {
+	    if (atomic_read(&AudioRingFilled) < AUDIO_RING_MAX) {
+		break;
+	    }
+	    Debug(3, "audio: flush out of ring buffers\n");
+	    usleep(1 * 1000);		// avoid hot polling
+	}
+	if (atomic_read(&AudioRingFilled) >= AUDIO_RING_MAX) {
+	    // FIXME: We can set the flush flag in the last wrote ring buffer
+	    Error(_("audio: flush out of ring buffers\n"));
+	    return;
+	}
+    }
+
     old = AudioRingWrite;
-    // FIXME: check ring buffer overflow
     AudioRingWrite = (AudioRingWrite + 1) % AUDIO_RING_MAX;
     AudioRing[AudioRingWrite].FlushBuffers = 1;
     AudioRing[AudioRingWrite].Passthrough = AudioRing[old].Passthrough;
@@ -2439,12 +2483,13 @@
 
     atomic_inc(&AudioRingFilled);
 
-    // FIXME: wait for flush complete?
+    // FIXME: wait for flush complete needed?
     for (i = 0; i < 24 * 2; ++i) {
 	if (!AudioRunning) {		// wakeup thread to flush buffers
 	    AudioRunning = 1;
 	    pthread_cond_signal(&AudioStartCond);
 	}
+	// FIXME: waiting on zero isn't correct, but currently works
 	if (!atomic_read(&AudioRingFilled)) {
 	    break;
 	}
@@ -2757,6 +2802,20 @@
 }
 
 /**
+**	Set automatic AES flag handling.
+**
+**	@param onoff	turn setting AES flag on or off
+*/
+void AudioSetAutoAES(int onoff)
+{
+    if (onoff < 0) {
+	AudioAppendAES ^= 1;
+    } else {
+	AudioAppendAES = onoff;
+    }
+}
+
+/**
 **	Initialize audio output module.
 **
 **	@todo FIXME: make audio output module selectable.
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/audio.h git/audio.h
--- vdr-plugin-softhddevice-0.6.1rc1/audio.h	2013-09-30 20:54:27.000000000 +0200
+++ git/audio.h	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file audio.h		@brief Audio module headerfile
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: da055758af70cfdb9ab1989d5fcfb218c5d6a366 $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Audio
@@ -52,6 +52,7 @@
     /// set pass-through device
 extern void AudioSetPassthroughDevice(const char *);
 extern void AudioSetChannel(const char *);	///< set mixer channel
+extern void AudioSetAutoAES(int);	///< set automatic AES flag handling
 extern void AudioInit(void);		///< setup audio module
 extern void AudioExit(void);		///< cleanup and exit audio module
 
@@ -60,5 +61,7 @@
 //----------------------------------------------------------------------------
 
 extern char AudioAlsaDriverBroken;	///< disable broken driver message
+extern char AudioAlsaNoCloseOpen;	///< disable alsa close/open fix
+extern char AudioAlsaCloseOpenDelay;	///< enable alsa close/open delay fix
 
 /// @}
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/ChangeLog git/ChangeLog
--- vdr-plugin-softhddevice-0.6.1rc1/ChangeLog	2013-09-30 20:54:27.000000000 +0200
+++ git/ChangeLog	2014-06-25 20:06:27.000000000 +0200
@@ -1,6 +1,61 @@
 User johns
 Date:
 
+    Config for automatic AES parameters.
+    Use GCC built-in functions for atomic operations.
+
+User master_red
+Date: Wed Jun  4 14:44:32 CEST 2014
+
+    Support detach or suspend in plugin menu.
+
+User johns
+Date:  Fri May 30 10:18:20 CEST 2014
+
+    Fix "make clean-plugins".
+    Fix compile with newer libav.
+    Fix OSD bugs.
+    Add some VA-API VPP info outputs.
+    Remove build files for old unstable VDR.
+
+User  hd.brummy
+Date: Thu Jan 30 10:40:49 CET 2014
+
+    Update gentoo ebuild.
+
+User johns
+Date: Thu Jan 30 10:36:53 CET 2014
+
+    Fix spelling in arguments help.
+    Add Workaround for alsa blocking audio device.
+    Improves thread handling for audio flush and close.
+
+User mini73
+Date: Fri Jan 24 11:30:49 CET 2014
+
+    Fix bug: learing x11 remote keys fails.
+    Add support for umlauts in input fields.
+
+User johns
+Date: Tue Jan 14 14:59:44 CET 2014
+
+    Fix alternative OSD support with VDPAU bitmap surfaces.
+    Fix compile error with VDR 2.1.3.
+    Fix bug: memory leak.
+    PIP close clears the last used PIP channel.
+    Fix bug: -DOSD_DEBUG uses old (deleted) variable.
+    Fix bug: Option softhddevice.BlackPicture has no effect.
+
+User Dr. Seltsam
+Date: Tue Nov  5 16:46:34 CET 2013
+
+    Add support to configure and clear buffers on channel switch.
+
+User johns
+Date: Tue Oct  8 10:18:04 CET 2013
+
+    CLOCK_REALTIME -> CLOCK_MONOTONIC to allow time changes.
+    Add function VideoStreamOpen and always use VideoStreamClose.
     Softer audio/video sync.
     Add function GetStats to the video output module.
     Add function ResetStart to the video output module.
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/codec.c git/codec.c
--- vdr-plugin-softhddevice-0.6.1rc1/codec.c	2013-09-30 20:54:27.000000000 +0200
+++ git/codec.c	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file codec.c	@brief Codec functions
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 03ba0289efb496b604f7e150bcf7bab09d94c551 $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -38,8 +38,12 @@
 #define USE_AC3_DRIFT_CORRECTION
     /// use ffmpeg libswresample API (autodected, Makefile)
 #define noUSE_SWRESAMPLE
+    /// use libav libavresample API (autodected, Makefile)
+#define noUSE_AVRESAMPLE
 
 #include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
 #ifdef __FreeBSD__
 #include <sys/endian.h>
@@ -54,8 +58,8 @@
 #define _(str) gettext(str)		///< gettext shortcut
 #define _N(str) str			///< gettext_noop shortcut
 
-#include <alsa/iatomic.h>
 #include <libavcodec/avcodec.h>
+#include <libavutil/mem.h>
 // support old ffmpeg versions <1.0
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(55,18,102)
 #define AVCodecID CodecID
@@ -70,6 +74,10 @@
 #ifdef USE_SWRESAMPLE
 #include <libswresample/swresample.h>
 #endif
+#ifdef USE_AVRESAMPLE
+#include <libavresample/avresample.h>
+#include <libavutil/opt.h>
+#endif
 
 #ifndef __USE_GNU
 #define __USE_GNU
@@ -79,6 +87,7 @@
 #ifdef MAIN_H
 #include MAIN_H
 #endif
+#include "iatomic.h"
 #include "misc.h"
 #include "video.h"
 #include "audio.h"
@@ -201,7 +210,9 @@
 
 	//Debug(3, "codec: use surface %#010x\n", surface);
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,48,101)
 	frame->type = FF_BUFFER_TYPE_USER;
+#endif
 #if LIBAVCODEC_VERSION_INT <= AV_VERSION_INT(53,46,0)
 	frame->age = 256 * 256 * 256 * 64;
 #endif
@@ -211,12 +222,14 @@
 	frame->data[2] = NULL;
 	frame->data[3] = NULL;
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,66,100)
 	// reordered frames
 	if (video_ctx->pkt) {
 	    frame->pkt_pts = video_ctx->pkt->pts;
 	} else {
 	    frame->pkt_pts = AV_NOPTS_VALUE;
 	}
+#endif
 	return 0;
     }
 #endif
@@ -228,7 +241,9 @@
 
 	//Debug(3, "codec: use surface %#010x\n", surface);
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,48,101)
 	frame->type = FF_BUFFER_TYPE_USER;
+#endif
 #if LIBAVCODEC_VERSION_INT <= AV_VERSION_INT(53,46,0)
 	frame->age = 256 * 256 * 256 * 64;
 #endif
@@ -236,12 +251,14 @@
 	frame->data[0] = (void *)(size_t) surface;
 	frame->data[3] = (void *)(size_t) surface;
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(52,66,100)
 	// reordered frames
 	if (video_ctx->pkt) {
 	    frame->pkt_pts = video_ctx->pkt->pts;
 	} else {
 	    frame->pkt_pts = AV_NOPTS_VALUE;
 	}
+#endif
 	return 0;
     }
     //Debug(3, "codec: fallback to default get_buffer\n");
@@ -664,15 +681,18 @@
     int HwSampleRate;			///< hw sample rate
     int HwChannels;			///< hw channels
 
-#ifndef USE_SWRESAMPLE
-    ReSampleContext *ReSample;		///< audio resampling context
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
+    ReSampleContext *ReSample;		///< old resampling context
 #endif
 #ifdef USE_SWRESAMPLE
 #if LIBSWRESAMPLE_VERSION_INT < AV_VERSION_INT(0, 15, 100)
-    struct SwrContext *Resample;	///< audio software resample context
+    struct SwrContext *Resample;	///< ffmpeg software resample context
 #else
-    SwrContext *Resample;		///< audio software resample context
+    SwrContext *Resample;		///< ffmpeg software resample context
+#endif
 #endif
+#ifdef USE_AVRESAMPLE
+    AVAudioResampleContext *Resample;	///< libav software resample context
 #endif
 
     uint16_t Spdif[24576 / 2];		///< SPDIF output buffer
@@ -687,7 +707,7 @@
     int DriftCorr;			///< audio drift correction value
     int DriftFrac;			///< audio drift fraction for ac3
 
-#ifndef USE_SWRESAMPLE
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
     struct AVResampleContext *AvResample;	///< second audio resample context
 #define MAX_CHANNELS 8			///< max number of channels supported
     int16_t *Buffer[MAX_CHANNELS];	///< deinterleave sample buffers
@@ -785,7 +805,7 @@
 	    AV_CH_LAYOUT_STEREO_DOWNMIX;
     }
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53,61,100)
-    // this has no effect
+    // this has no effect (with ffmpeg and libav)
     // audio_decoder->AudioCtx->request_sample_fmt = AV_SAMPLE_FMT_S16;
 #endif
     pthread_mutex_lock(&CodecLockMutex);
@@ -834,7 +854,7 @@
 void CodecAudioClose(AudioDecoder * audio_decoder)
 {
     // FIXME: output any buffered data
-#ifndef USE_SWRESAMPLE
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
     if (audio_decoder->AvResample) {
 	int ch;
 
@@ -860,6 +880,11 @@
 	swr_free(&audio_decoder->Resample);
     }
 #endif
+#ifdef USE_AVRESAMPLE
+    if (audio_decoder->Resample) {
+	avresample_free(&audio_decoder->Resample);
+    }
+#endif
     if (audio_decoder->AudioCtx) {
 	pthread_mutex_lock(&CodecLockMutex);
 	avcodec_close(audio_decoder->AudioCtx);
@@ -1155,7 +1180,7 @@
     return 0;
 }
 
-#ifndef USE_SWRESAMPLE
+#if !defined(USE_SWRESAMPLE) && !defined(USE_AVRESAMPLE)
 
 /**
 **	Set/update audio pts clock.
@@ -1557,7 +1582,7 @@
 
 #endif
 
-#ifdef USE_SWRESAMPLE
+#if defined(USE_SWRESAMPLE) || defined(USE_AVRESAMPLE)
 
 /**
 **	Set/update audio pts clock.
@@ -1646,6 +1671,7 @@
 	}
     }
 
+#ifdef USE_SWRESAMPLE
     if (audio_decoder->Resample && audio_decoder->DriftCorr) {
 	int distance;
 
@@ -1660,6 +1686,18 @@
 	    Debug(3, "codec/audio: swr_set_compensation failed\n");
 	}
     }
+#endif
+#ifdef USE_AVRESAMPLE
+    if (audio_decoder->Resample && audio_decoder->DriftCorr) {
+	int distance;
+
+	distance = (pts_diff * audio_decoder->HwSampleRate) / (900 * 1000);
+	if (avresample_set_compensation(audio_decoder->Resample,
+		audio_decoder->DriftCorr / 10, distance)) {
+	    Debug(3, "codec/audio: swr_set_compensation failed\n");
+	}
+    }
+#endif
     if (1) {
 	static int c;
 
@@ -1699,6 +1737,7 @@
     }
 #endif
 
+#ifdef USE_SWRESAMPLE
     audio_decoder->Resample =
 	swr_alloc_set_opts(audio_decoder->Resample, audio_ctx->channel_layout,
 	AV_SAMPLE_FMT_S16, audio_decoder->HwSampleRate,
@@ -1709,6 +1748,33 @@
     } else {
 	Error(_("codec/audio: can't setup resample\n"));
     }
+#endif
+#ifdef USE_AVRESAMPLE
+    if (!(audio_decoder->Resample = avresample_alloc_context())) {
+	Error(_("codec/audio: can't setup resample\n"));
+	return;
+    }
+
+    av_opt_set_int(audio_decoder->Resample, "in_channel_layout",
+	audio_ctx->channel_layout, 0);
+    av_opt_set_int(audio_decoder->Resample, "in_sample_fmt",
+	audio_ctx->sample_fmt, 0);
+    av_opt_set_int(audio_decoder->Resample, "in_sample_rate",
+	audio_ctx->sample_rate, 0);
+    av_opt_set_int(audio_decoder->Resample, "out_channel_layout",
+	audio_ctx->channel_layout, 0);
+    av_opt_set_int(audio_decoder->Resample, "out_sample_fmt",
+	AV_SAMPLE_FMT_S16, 0);
+    av_opt_set_int(audio_decoder->Resample, "out_sample_rate",
+	audio_decoder->HwSampleRate, 0);
+
+    if (avresample_open(audio_decoder->Resample)) {
+	avresample_free(&audio_decoder->Resample);
+	audio_decoder->Resample = NULL;
+	Error(_("codec/audio: can't open resample\n"));
+	return;
+    }
+#endif
 }
 
 /**
@@ -1731,7 +1797,9 @@
     audio_ctx = audio_decoder->AudioCtx;
 
     // FIXME: don't need to decode pass-through codecs
-    frame.data[0] = NULL;
+    // libav needs memset, frame.data[0] = NULL;
+    memset(&frame, 0, sizeof(frame));
+    got_frame = 0;
     n = avcodec_decode_audio4(audio_ctx, &frame, &got_frame,
 	(AVPacket *) avpkt);
     if (n != avpkt->size) {
@@ -1785,7 +1853,7 @@
 	    "codec/audio: channels %d samples %d plane %d data %d\n",
 	    audio_ctx->channels, frame.nb_samples, plane_sz, data_sz);
     }
-
+#ifdef USE_SWRESAMPLE
     if (audio_decoder->Resample) {
 	uint8_t outbuf[8192 * 2 * 8];
 	uint8_t *out[1];
@@ -1804,6 +1872,30 @@
 	}
 	return;
     }
+#endif
+
+#ifdef USE_AVRESAMPLE
+    if (audio_decoder->Resample) {
+	uint8_t outbuf[8192 * 2 * 8];
+	uint8_t *out[1];
+
+	out[0] = outbuf;
+	n = avresample_convert(audio_decoder->Resample, out, 0,
+	    sizeof(outbuf) / (2 * audio_decoder->HwChannels),
+	    (uint8_t **) frame.extended_data, 0, frame.nb_samples);
+	// FIXME: set out_linesize, in_linesize correct
+	if (n > 0) {
+	    if (!(audio_decoder->Passthrough & CodecPCM)) {
+		CodecReorderAudioFrame((int16_t *) outbuf,
+		    n * 2 * audio_decoder->HwChannels,
+		    audio_decoder->HwChannels);
+	    }
+	    AudioEnqueue(outbuf, n * 2 * audio_decoder->HwChannels);
+	}
+	return;
+    }
+#endif
+
 #ifdef DEBUG
     // should be never reached
     fprintf(stderr, "oops\n");
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/codec.h git/codec.h
--- vdr-plugin-softhddevice-0.6.1rc1/codec.h	2013-09-30 20:54:27.000000000 +0200
+++ git/codec.h	2014-06-25 20:06:27.000000000 +0200
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 995573a37d63ab35ed13aed6ca333eebe2041c3e $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Codec
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/iatomic.h git/iatomic.h
--- vdr-plugin-softhddevice-0.6.1rc1/iatomic.h	1970-01-01 01:00:00.000000000 +0100
+++ git/iatomic.h	2014-06-25 20:06:27.000000000 +0200
@@ -0,0 +1,97 @@
+///
+///	@file iatomic.h @brief Misc function header file
+///
+///	Copyright (c) 2014 by Johns.  All Rights Reserved.
+///
+///	Contributor(s):
+///
+///	License: AGPLv3
+///
+///	This program is free software: you can redistribute it and/or modify
+///	it under the terms of the GNU Affero General Public License as
+///	published by the Free Software Foundation, either version 3 of the
+///	License.
+///
+///	This program is distributed in the hope that it will be useful,
+///	but WITHOUT ANY WARRANTY; without even the implied warranty of
+///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+///	GNU Affero General Public License for more details.
+///
+///	$Id: 59e1684aaa6678ecdebb6ce0df6ce5b5f461dd6e $
+//////////////////////////////////////////////////////////////////////////////
+
+/// @addtogroup iatomic
+/// @{
+
+#define GCC_VERSION (__GNUC__ * 10000 \
+	+ __GNUC_MINOR__ * 100 \
+	+ __GNUC_PATCHLEVEL__)
+
+//	gcc before 4.7 didn't support atomic builtins,
+//	use alsa atomic functions.
+#if GCC_VERSION < 40700
+
+#include <alsa/iatomic.h>
+
+#else
+
+//////////////////////////////////////////////////////////////////////////////
+//	Defines
+//////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////
+//	Declares
+//////////////////////////////////////////////////////////////////////////////
+
+///
+///	atomic type, 24 bit useable,
+///
+typedef volatile int atomic_t;
+
+//////////////////////////////////////////////////////////////////////////////
+//	Prototypes
+//////////////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////////
+//	Inlines
+//////////////////////////////////////////////////////////////////////////////
+
+///
+///	Set atomic value.
+///
+#define atomic_set(ptr, val) \
+    __atomic_store_n(ptr, val, __ATOMIC_SEQ_CST)
+
+///
+///	Read atomic value.
+///
+#define atomic_read(ptr) \
+    __atomic_load_n(ptr, __ATOMIC_SEQ_CST)
+
+///
+///	Increment atomic value.
+///
+#define atomic_inc(ptr) \
+    __atomic_add_fetch(ptr, 1, __ATOMIC_SEQ_CST)
+
+///
+///	Decrement atomic value.
+///
+#define atomic_dec(ptr) \
+    __atomic_sub_fetch(ptr, 1, __ATOMIC_SEQ_CST)
+
+///
+///	Add to atomic value.
+///
+#define atomic_add(val, ptr) \
+    __atomic_add_fetch(ptr, val, __ATOMIC_SEQ_CST)
+
+///
+///	Subtract from atomic value.
+///
+#define atomic_sub(val, ptr) \
+    __atomic_sub_fetch(ptr, val, __ATOMIC_SEQ_CST)
+
+#endif
+
+/// @}
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/Makefile git/Makefile
--- vdr-plugin-softhddevice-0.6.1rc1/Makefile	2013-09-30 20:54:27.000000000 +0200
+++ git/Makefile	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 #
 # Makefile for a Video Disk Recorder plugin
 #
-# $Id$
+# $Id: 187a9170996aed0b5a1783e229edddd9f4d628c7 $
 
 # The official name of this plugin.
 # This name will be used in the '-P...' option of VDR to load the plugin.
@@ -25,6 +25,10 @@
 SCREENSAVER ?= 1
     # use ffmpeg libswresample
 SWRESAMPLE ?= $(shell pkg-config --exists libswresample && echo 1)
+    # use libav libavresample
+ifneq ($(SWRESAMPLE),1)
+AVRESAMPLE ?= $(shell pkg-config --exists libavresample && echo 1)
+endif
 
 CONFIG := # -DDEBUG #-DOSD_DEBUG	# enable debug output+functions
 #CONFIG += -DSTILL_DEBUG=2		# still picture debug verbose level
@@ -37,6 +41,7 @@
 #CONFIG += -DUSE_MPEG_COMPLETE		# support only complete mpeg packets
 #CONFIG += -DH264_EOS_TRICKSPEED	# insert seq end packets for trickspeed
 #CONDIF += -DDUMP_TRICKSPEED		# dump trickspeed packets
+#CONFIG += -DUSE_BITMAP			# VDPAU, use bitmap surface for OSD
 CONFIG += -DUSE_VDR_SPU			# use VDR SPU decoder.
 #CONFIG += -DUSE_SOFTLIMIT		# (tobe removed) limit the buffer fill
 
@@ -77,6 +82,11 @@
 _CFLAGS += $(shell pkg-config --cflags libswresample)
 LIBS += $(shell pkg-config --libs libswresample)
 endif
+ifeq ($(AVRESAMPLE),1)
+CONFIG += -DUSE_AVRESAMPLE
+_CFLAGS += $(shell pkg-config --cflags libavresample)
+LIBS += $(shell pkg-config --libs libavresample)
+endif
 
 _CFLAGS += $(shell pkg-config --cflags libavcodec x11 x11-xcb xcb xcb-icccm)
 LIBS += -lrt $(shell pkg-config --libs libavcodec x11 x11-xcb xcb xcb-icccm)
@@ -102,10 +112,10 @@
 export CXXFLAGS = $(call PKGCFG,cxxflags)
 
 ifeq ($(CFLAGS),)
-$(error CFLAGS not set)
+$(warning CFLAGS not set)
 endif
 ifeq ($(CXXFLAGS),)
-$(error CXXFLAGS not set)
+$(warning CXXFLAGS not set)
 endif
 
 ### The version number of VDR's plugin API:
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/misc.h git/misc.h
--- vdr-plugin-softhddevice-0.6.1rc1/misc.h	2013-09-30 20:54:27.000000000 +0200
+++ git/misc.h	2014-06-25 20:06:27.000000000 +0200
@@ -18,7 +18,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: f5ff4b300aa33eb721d658c0c9374c8499b67318 $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup misc
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/po/de_DE.po git/po/de_DE.po
--- vdr-plugin-softhddevice-0.6.1rc1/po/de_DE.po	2013-09-30 20:54:27.000000000 +0200
+++ git/po/de_DE.po	2014-06-25 20:06:27.000000000 +0200
@@ -7,7 +7,7 @@
 msgstr ""
 "Project-Id-Version: VDR \n"
 "Report-Msgid-Bugs-To: <see README>\n"
-"POT-Creation-Date: 2013-08-03 17:21+0200\n"
+"POT-Creation-Date: 2014-03-20 11:50+0100\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -239,6 +239,9 @@
 msgid "audio: can't place %d samples in ring buffer\n"
 msgstr ""
 
+msgid "audio: flush out of ring buffers\n"
+msgstr ""
+
 #, c-format
 msgid "audio: '%s' output module used\n"
 msgstr ""
@@ -306,6 +309,9 @@
 msgid "codec/audio: can't setup resample\n"
 msgstr ""
 
+msgid "codec/audio: can't open resample\n"
+msgstr ""
+
 msgid "codec/audio: latm\n"
 msgstr ""
 
@@ -483,6 +489,9 @@
 msgid "Suspend"
 msgstr "Unterbrechen"
 
+msgid "Detach from main menu entry"
+msgstr "Detach durch Hauptmenüeintrag"
+
 msgid "Suspend closes video+audio"
 msgstr "Unterbrechen schließt Video+Audio"
 
@@ -510,6 +519,9 @@
 msgid "Black during channel switch"
 msgstr "Schwarz während Kanalwechsel"
 
+msgid "Clear decoder on channel switch"
+msgstr "Decoder bei Kanalwechsel leeren"
+
 msgid "Brightness (-1000..1000) (vdpau)"
 msgstr "Helligkeit (-1000..1000) (vdpau)"
 
@@ -595,7 +607,7 @@
 msgstr ""
 
 msgid "Enable (E-)AC-3 (decoder) downmix"
-msgstr ""
+msgstr "Aktiviere (E-)AC-3 (decoder) downmix"
 
 msgid "Volume control"
 msgstr "Lautstärkesteuerung"
@@ -624,6 +636,9 @@
 msgid "Audio buffer size (ms)"
 msgstr "Audio Puffergröße (ms)"
 
+msgid "Enable automatic AES"
+msgstr "Aktiviere automatiche AES"
+
 msgid "Picture-In-Picture"
 msgstr "Bild in Bild (PIP)"
 
@@ -688,6 +703,9 @@
 msgid "Channel not available!"
 msgstr "Kanal nicht verfügbar!"
 
+msgid "Detach SoftHdDevice"
+msgstr ""
+
 msgid "Suspend SoftHdDevice"
 msgstr "Unterbreche SoftHdDevice"
 
@@ -1031,7 +1049,7 @@
 msgid "video/vaapi: can't find a supported subpicture format"
 msgstr ""
 
-msgid "video/vaapi: vaapi supports unscaled osd\n"
+msgid "video/vaapi: supports unscaled osd\n"
 msgstr ""
 
 msgid "video/vaapi: can't create osd image\n"
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/README.txt git/README.txt
--- vdr-plugin-softhddevice-0.6.1rc1/README.txt	2013-09-30 20:54:27.000000000 +0200
+++ git/README.txt	2014-06-25 20:06:27.000000000 +0200
@@ -16,7 +16,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.
 
-$Id$
+$Id: 62372e3a14be6cf6808703c62ec30d0e1a9bb651 $
 
 A software and GPU emulated HD output device plugin for VDR.
 
@@ -233,6 +233,10 @@
 	0 disable black picture during channel switch
 	1 enable black picture during channel switch
 
+	softhddevice.ClearOnSwitch = 0
+	0 keep video und audio buffers during channel switch
+	1 clear video and audio buffers on channel switch
+
 	softhddevice.Video4to3DisplayFormat = 1
 	0 pan and scan
 	1 letter box
@@ -352,7 +356,7 @@
 
 	media-video/ffmpeg (version >=0.7)
 		Complete solution to record, convert and stream audio and
-		video. Includes libavcodec.
+		video. Includes libavcodec and libswresample.
 		http://ffmpeg.org
 	media-libs/alsa-lib
 		Advanced Linux Sound Architecture Library
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/ringbuffer.c git/ringbuffer.c
--- vdr-plugin-softhddevice-0.6.1rc1/ringbuffer.c	2013-09-30 20:54:27.000000000 +0200
+++ git/ringbuffer.c	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file ringbuffer.c	@brief Ringbuffer module
 ///
-///	Copyright (c) 2009, 2011  by Johns.  All Rights Reserved.
+///	Copyright (c) 2009, 2011, 2014	by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: c9497b197ce7e7a6ba397944edc7ccb161152efd $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -30,8 +30,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include <alsa/iatomic.h>
-
+#include "iatomic.h"
 #include "ringbuffer.h"
 
     /// ring buffer structure
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/ringbuffer.h git/ringbuffer.h
--- vdr-plugin-softhddevice-0.6.1rc1/ringbuffer.h	2013-09-30 20:54:27.000000000 +0200
+++ git/ringbuffer.h	2014-06-25 20:06:27.000000000 +0200
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 8a2b4c171f1024afb8b8a7a7add631b7ebe2d45e $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Ringbuffer
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/softhddev.c git/softhddev.c
--- vdr-plugin-softhddevice-0.6.1rc1/softhddev.c	2013-09-30 20:54:27.000000000 +0200
+++ git/softhddev.c	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file softhddev.c	@brief A software HD device plugin for VDR.
 ///
-///	Copyright (c) 2011 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2011 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 175910934e6830fd90469d804f3d24119625caec $
 //////////////////////////////////////////////////////////////////////////////
 
 #define noUSE_SOFTLIMIT			///< add soft buffer limits to Play..
@@ -32,15 +32,18 @@
 #include <fcntl.h>
 
 #include <stdio.h>
+#include <stdlib.h>
 #include <stdint.h>
 #include <inttypes.h>
 #include <unistd.h>
+#include <string.h>
 
 #include <libintl.h>
 #define _(str) gettext(str)		///< gettext shortcut
 #define _N(str) str			///< gettext_noop shortcut
 
 #include <libavcodec/avcodec.h>
+#include <libavutil/mem.h>
 // support old ffmpeg versions <1.0
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(55,18,102)
 #define AVCodecID CodecID
@@ -60,6 +63,7 @@
 #endif
 #include <pthread.h>
 
+#include "iatomic.h"			// portable atomic_t
 #include "misc.h"
 #include "softhddev.h"
 
@@ -83,6 +87,7 @@
 #endif
 
 extern int ConfigAudioBufferTime;	///< config size ms of audio buffer
+extern int ConfigVideoClearOnSwitch;	//<  clear decoder on channel switch
 char ConfigStartX11Server;		///< flag start the x11 server
 static char ConfigStartSuspended;	///< flag to start in suspend mode
 static char ConfigFullscreen;		///< fullscreen modus
@@ -1303,8 +1308,6 @@
 //	Video
 //////////////////////////////////////////////////////////////////////////////
 
-#include <alsa/iatomic.h>		// portable atomic_t
-
 #define VIDEO_BUFFER_SIZE (512 * 1024)	///< video PES buffer default size
 #define VIDEO_PACKET_MAX 192		///< max number of video packets
 
@@ -1743,22 +1746,40 @@
 #endif
 
 /**
+**	Open video stream.
+**
+**	@param stream	video stream
+*/
+static void VideoStreamOpen(VideoStream * stream)
+{
+    stream->SkipStream = 1;
+    stream->CodecID = AV_CODEC_ID_NONE;
+    stream->LastCodecID = AV_CODEC_ID_NONE;
+
+    if ((stream->HwDecoder = VideoNewHwDecoder(stream))) {
+	stream->Decoder = CodecVideoNewDecoder(stream->HwDecoder);
+	VideoPacketInit(stream);
+	stream->SkipStream = 0;
+    }
+}
+
+/**
 **	Close video stream.
 **
 **	@param stream	video stream
+**	@param delhw	flag delete hardware decoder
 **
-**	@note must be called from the video thread, othewise xcb has a
+**	@note must be called from the video thread, otherwise xcb has a
 **	deadlock.
 */
-static void VideoStreamClose(VideoStream * stream)
+static void VideoStreamClose(VideoStream * stream, int delhw)
 {
-    // FIXME: use this function to close the main video stream!
     stream->SkipStream = 1;
     if (stream->Decoder) {
 	VideoDecoder *decoder;
 
 	decoder = stream->Decoder;
-	// FIXME: this lock shouldn't be necessary now
+	// FIXME: remove this lock for main stream close
 	pthread_mutex_lock(&stream->DecoderLockMutex);
 	stream->Decoder = NULL;		// lock read thread
 	pthread_mutex_unlock(&stream->DecoderLockMutex);
@@ -1766,7 +1787,9 @@
 	CodecVideoDelDecoder(decoder);
     }
     if (stream->HwDecoder) {
-	VideoDelHwDecoder(stream->HwDecoder);
+	if (delhw) {
+	    VideoDelHwDecoder(stream->HwDecoder);
+	}
 	stream->HwDecoder = NULL;
 	// FIXME: CodecVideoClose calls/uses hw decoder
     }
@@ -1796,13 +1819,14 @@
     }
 
     if (stream->Close) {		// close stream request
-	VideoStreamClose(stream);
+	VideoStreamClose(stream, 1);
 	stream->Close = 0;
 	return 1;
     }
     if (stream->ClearBuffers) {		// clear buffer request
 	atomic_set(&stream->PacketsFilled, 0);
 	stream->PacketRead = stream->PacketWrite;
+	// FIXME: ->Decoder already checked
 	if (stream->Decoder) {
 	    CodecVideoFlushBuffers(stream->Decoder);
 	    VideoResetStart(stream->HwDecoder);
@@ -1839,13 +1863,14 @@
     }
 
     if (stream->Close) {		// close stream request
-	VideoStreamClose(stream);
+	VideoStreamClose(stream, 1);
 	stream->Close = 0;
 	return 1;
     }
     if (stream->ClearBuffers) {		// clear buffer request
 	atomic_set(&stream->PacketsFilled, 0);
 	stream->PacketRead = stream->PacketWrite;
+	// FIXME: ->Decoder already checked
 	if (stream->Decoder) {
 	    CodecVideoFlushBuffers(stream->Decoder);
 	    VideoResetStart(stream->HwDecoder);
@@ -1988,17 +2013,8 @@
     }
     VideoOsdInit();
     if (!MyVideoStream->Decoder) {
-	MyVideoStream->SkipStream = 1;
-	MyVideoStream->CodecID = AV_CODEC_ID_NONE;
-	MyVideoStream->LastCodecID = AV_CODEC_ID_NONE;
-
-	if ((MyVideoStream->HwDecoder = VideoNewHwDecoder(MyVideoStream))) {
-	    MyVideoStream->Decoder =
-		CodecVideoNewDecoder(MyVideoStream->HwDecoder);
-	    VideoPacketInit(MyVideoStream);
-	    AudioSyncStream = MyVideoStream;
-	    MyVideoStream->SkipStream = 0;
-	}
+	VideoStreamOpen(MyVideoStream);
+	AudioSyncStream = MyVideoStream;
     }
 }
 
@@ -2010,6 +2026,10 @@
     VideoOsdExit();
     VideoExit();
     AudioSyncStream = NULL;
+#if 1
+    // FIXME: done by exit: VideoDelHwDecoder(MyVideoStream->HwDecoder);
+    VideoStreamClose(MyVideoStream, 0);
+#else
     MyVideoStream->SkipStream = 1;
     if (MyVideoStream->Decoder) {
 	VideoDecoder *decoder;
@@ -2030,6 +2050,7 @@
 
     MyVideoStream->NewStream = 1;
     MyVideoStream->InvalidPesCounter = 0;
+#endif
 }
 
 #ifdef DEBUG
@@ -2447,45 +2468,48 @@
 */
 int SetPlayMode(int play_mode)
 {
-    VideoDisplayWakeup();
-    // tell video parser we have new stream
-    if (MyVideoStream->Decoder && !MyVideoStream->SkipStream) {
-	if (MyVideoStream->ClearClose) {	// replay clear buffers on close
-	    Clear();			// flush all buffers
-	    MyVideoStream->ClearClose = 0;
-	}
-	if (MyVideoStream->CodecID != AV_CODEC_ID_NONE) {
-	    MyVideoStream->NewStream = 1;
-	    MyVideoStream->InvalidPesCounter = 0;
-	    // tell hw decoder we are closing stream
-	    VideoSetClosing(MyVideoStream->HwDecoder);
-	    VideoResetStart(MyVideoStream->HwDecoder);
-#ifdef DEBUG
-	    VideoSwitch = GetMsTicks();
-#endif
-	}
-    }
-    if (MyAudioDecoder) {		// tell audio parser we have new stream
-	if (AudioCodecID != AV_CODEC_ID_NONE) {
-	    NewAudioStream = 1;
-	}
-    }
     switch (play_mode) {
-	case 0:			// nothing
-	case 1:			// audio/video from player
+	case 0:			// audio/video from decoder
+	    // tell video parser we get new stream
+	    if (MyVideoStream->Decoder && !MyVideoStream->SkipStream) {
+		// clear buffers on close configured always or replay only
+		if (ConfigVideoClearOnSwitch || MyVideoStream->ClearClose) {
+		    Clear();		// flush all buffers
+		    MyVideoStream->ClearClose = 0;
+		}
+		if (MyVideoStream->CodecID != AV_CODEC_ID_NONE) {
+		    MyVideoStream->NewStream = 1;
+		    MyVideoStream->InvalidPesCounter = 0;
+		    // tell hw decoder we are closing stream
+		    VideoSetClosing(MyVideoStream->HwDecoder);
+		    VideoResetStart(MyVideoStream->HwDecoder);
+#ifdef DEBUG
+		    VideoSwitch = GetMsTicks();
+		    Debug(3, "video: new stream start\n");
+#endif
+		}
+	    }
+	    if (MyAudioDecoder) {	// tell audio parser we have new stream
+		if (AudioCodecID != AV_CODEC_ID_NONE) {
+		    NewAudioStream = 1;
+		}
+	    }
 	    break;
-	case 2:			// audio only
-	    Debug(3, "softhddev: FIXME: audio only, silence video errors\n");
+	case 1:			// audio/video from player
+	    VideoDisplayWakeup();
+	    Play();
 	    break;
-	case 3:			// audio only, black screen
+	case 2:			// audio only from player, video from decoder
+	case 3:			// audio only from player, no video (black screen)
 	    Debug(3, "softhddev: FIXME: audio only, silence video errors\n");
+	    VideoDisplayWakeup();
+	    Play();
 	    break;
-	case 4:			// video only
+	case 4:			// video only from player, audio from decoder
+	    VideoDisplayWakeup();
+	    Play();
 	    break;
     }
-
-    Play();
-
     return 1;
 }
 
@@ -2569,8 +2593,10 @@
 
     VideoResetPacket(MyVideoStream);	// terminate work
     MyVideoStream->ClearBuffers = 1;
-    AudioFlushBuffers();
-    //NewAudioStream = 1;
+    if (!SkipAudio) {
+	AudioFlushBuffers();
+	//NewAudioStream = 1;
+    }
     // FIXME: audio avcodec_flush_buffers, video is done by VideoClearBuffers
 
     // wait for empty buffers
@@ -2866,6 +2892,8 @@
 	"\tstill-hw-decoder\tenable hardware decoder for still-pictures\n"
 	"\tstill-h264-hw-decoder\tenable h264 hw decoder for still-pictures\n"
 	"\talsa-driver-broken\tdisable broken alsa driver message\n"
+	"\talsa-no-close-open\tdisable close open to fix alsa no sound bug\n"
+	"\talsa-close-open-delay\tenable close open delay to fix no sound bug\n"
 	"\tignore-repeat-pict\tdisable repeat pict message\n"
 	"  -D\t\tstart in detached mode\n";
 }
@@ -2942,6 +2970,10 @@
 		    ConfigStillDecoder = 1;
 		} else if (!strcasecmp("alsa-driver-broken", optarg)) {
 		    AudioAlsaDriverBroken = 1;
+		} else if (!strcasecmp("alsa-no-close-open", optarg)) {
+		    AudioAlsaNoCloseOpen = 1;
+		} else if (!strcasecmp("alsa-close-open-delay", optarg)) {
+		    AudioAlsaCloseOpenDelay = 1;
 		} else if (!strcasecmp("ignore-repeat-pict", optarg)) {
 		    VideoIgnoreRepeatPict = 1;
 		} else {
@@ -3280,6 +3312,8 @@
     DelPip();				// must stop PIP
 #endif
 
+    // FIXME: should not be correct, if not both are suspended!
+    // Move down into if (video) ...
     MyVideoStream->SkipStream = 1;
     SkipAudio = 1;
 
@@ -3426,16 +3460,7 @@
     }
 
     if (!PipVideoStream->Decoder) {
-	PipVideoStream->SkipStream = 1;
-	PipVideoStream->CodecID = AV_CODEC_ID_NONE;
-	PipVideoStream->LastCodecID = AV_CODEC_ID_NONE;
-
-	if ((PipVideoStream->HwDecoder = VideoNewHwDecoder(PipVideoStream))) {
-	    PipVideoStream->Decoder =
-		CodecVideoNewDecoder(PipVideoStream->HwDecoder);
-	    VideoPacketInit(PipVideoStream);
-	    PipVideoStream->SkipStream = 0;
-	}
+	VideoStreamOpen(PipVideoStream);
     }
     PipSetPosition(x, y, width, height, pip_x, pip_y, pip_width, pip_height);
 }
@@ -3453,34 +3478,11 @@
 
     ScaleVideo(0, 0, 0, 0);
 
-#if 0
-    PipVideoStream->SkipStream = 1;	// lock write thread
-    if (PipVideoStream->Decoder) {
-	VideoDecoder *decoder;
-
-	decoder = PipVideoStream->Decoder;
-	pthread_mutex_lock(&PipVideoStream->DecoderLockMutex);
-	PipVideoStream->Decoder = NULL;	// lock read thread
-	pthread_mutex_unlock(&PipVideoStream->DecoderLockMutex);
-	CodecVideoClose(decoder);
-	CodecVideoDelDecoder(decoder);
-    }
-    if (PipVideoStream->HwDecoder) {
-	VideoDelHwDecoder(PipVideoStream->HwDecoder);
-	PipVideoStream->HwDecoder = NULL;
-	// FIXME: CodecVideoClose calls/uses hw decoder
-    }
-    VideoPacketExit(PipVideoStream);
-
-    PipVideoStream->NewStream = 1;
-    PipVideoStream->InvalidPesCounter = 0;
-#else
     PipVideoStream->Close = 1;
     for (i = 0; PipVideoStream->Close && i < 50; ++i) {
 	usleep(1 * 1000);
     }
     Info("[softhddev]%s: pip close %dms\n", __FUNCTION__, i);
-#endif
 }
 
 /**
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/softhddev.h git/softhddev.h
--- vdr-plugin-softhddevice-0.6.1rc1/softhddev.h	2013-09-30 20:54:27.000000000 +0200
+++ git/softhddev.h	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file softhddev.h	@brief software HD device plugin header file.
 ///
-///	Copyright (c) 2011 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2011 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: da16ecedfaa417178e3f3341d0c190205ece69f6 $
 //////////////////////////////////////////////////////////////////////////////
 
 #ifdef __cplusplus
@@ -25,7 +25,8 @@
 {
 #endif
     /// C callback feed key press
-    extern void FeedKeyPress(const char *, const char *, int, int);
+    extern void FeedKeyPress(const char *, const char *, int, int,
+	const char *);
 
     /// C plugin get osd size and ascpect
     extern void GetOsdSize(int *, int *, double *);
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/softhddevice.cpp git/softhddevice.cpp
--- vdr-plugin-softhddevice-0.6.1rc1/softhddevice.cpp	2013-09-30 20:54:27.000000000 +0200
+++ git/softhddevice.cpp	2014-06-25 20:06:27.000000000 +0200
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: b3467a5df140e4d47495b998f17f897e3229fd06 $
 //////////////////////////////////////////////////////////////////////////////
 
 #define __STDC_CONSTANT_MACROS		///< needed for ffmpeg UINT64_C
@@ -79,6 +79,7 @@
 
 static char ConfigMakePrimary;		///< config primary wanted
 static char ConfigHideMainMenuEntry;	///< config hide main menu entry
+static char ConfigDetachFromMainMenu;	///< detach from main menu entry instead of suspend
 static char ConfigSuspendClose;		///< suspend should close devices
 static char ConfigSuspendX11;		///< suspend should stop x11
 
@@ -91,6 +92,7 @@
 static char ConfigVideo60HzMode;	///< config use 60Hz display mode
 static char ConfigVideoSoftStartSync;	///< config use softstart sync
 static char ConfigVideoBlackPicture;	///< config enable black picture mode
+char ConfigVideoClearOnSwitch;		///< config enable Clear on channel switch
 
 static int ConfigVideoBrightness;	///< config video brightness
 static int ConfigVideoContrast = 1000;	///< config video contrast
@@ -138,6 +140,7 @@
 static int ConfigAudioMaxCompression;	///< config max volume compression
 static int ConfigAudioStereoDescent;	///< config reduce stereo loudness
 int ConfigAudioBufferTime;		///< config size ms of audio buffer
+static int ConfigAudioAutoAES;		///< config automatic AES handling
 
 static char *ConfigX11Display;		///< config x11 display
 static char *ConfigAudioDevice;		///< config audio stereo device
@@ -211,9 +214,10 @@
 **	@param key	pressed/released key name
 **	@param repeat	repeated key flag
 **	@param release	released key flag
+**	@param letter	x11 character string (system setting locale)
 */
 extern "C" void FeedKeyPress(const char *keymap, const char *key, int repeat,
-    int release)
+    int release, const char *letter)
 {
     cRemote *remote;
     cSoftRemote *csoft;
@@ -236,9 +240,18 @@
 	csoft = new cSoftRemote(keymap);
     }
 
-    //dsyslog("[softhddev]%s %s, %s\n", __FUNCTION__, keymap, key);
+    //dsyslog("[softhddev]%s %s, %s, %s\n", __FUNCTION__, keymap, key, letter);
     if (key[1]) {			// no single character
-	csoft->Put(key, repeat, release);
+	if (!csoft->Put(key, repeat, release) && letter
+	    && !cRemote::IsLearning()) {
+	    cCharSetConv conv;
+	    unsigned code;
+
+	    code = Utf8CharGet(conv.Convert(letter));
+	    if (code <= 0xFF) {
+		cRemote::Put(KBDKEY(code));	// feed it for edit mode
+	    }
+	}
     } else if (!csoft->Put(key, repeat, release)) {
 	cRemote::Put(KBDKEY(key[0]));	// feed it for edit mode
     }
@@ -255,10 +268,12 @@
 {
   public:
     static volatile char Dirty;		///< flag force redraw everything
-    int OsdLevel;			///< current osd level
+    int OsdLevel;			///< current osd level FIXME: remove
 
      cSoftOsd(int, int, uint);		///< osd constructor
      virtual ~ cSoftOsd(void);		///< osd destructor
+    /// set the sub-areas to the given areas
+    virtual eOsdError SetAreas(const tArea *, int);
     virtual void Flush(void);		///< commits all data to the hardware
     virtual void SetActive(bool);	///< sets OSD to be the active one
 };
@@ -284,11 +299,6 @@
     }
     cOsd::SetActive(on);
 
-    // ignore sub-title if menu is open
-    if (OsdLevel >= OSD_LEVEL_SUBTITLES && IsOpen()) {
-	return;
-    }
-
     if (on) {
 	Dirty = 1;
 	// only flush here if there are already bitmaps
@@ -320,7 +330,6 @@
 #endif
 
     OsdLevel = level;
-    SetActive(true);
 }
 
 /**
@@ -352,6 +361,31 @@
 }
 
 /**
++*	Set the sub-areas to the given areas
+*/
+eOsdError cSoftOsd::SetAreas(const tArea * areas, int n)
+{
+#ifdef OSD_DEBUG
+    dsyslog("[softhddev]%s: %d areas \n", __FUNCTION__, n);
+#endif
+
+    // clear old OSD, when new areas are set
+    if (!IsTrueColor()) {
+	cBitmap *bitmap;
+	int i;
+
+	for (i = 0; (bitmap = GetBitmap(i)); i++) {
+	    bitmap->Clean();
+	}
+    }
+    if (Active()) {
+	VideoOsdClear();
+	Dirty = 1;
+    }
+    return cOsd::SetAreas(areas, n);
+}
+
+/**
 **	Actually commits all data to the OSD hardware.
 */
 void cSoftOsd::Flush(void)
@@ -366,10 +400,6 @@
     if (!Active()) {			// this osd is not active
 	return;
     }
-    // don't draw sub-title if menu is active
-    if (OsdLevel >= OSD_LEVEL_SUBTITLES && IsOpen()) {
-	return;
-    }
 #ifdef USE_YAEPG
     // support yaepghd, video window
     if (vidWin.bpp) {
@@ -385,17 +415,6 @@
     }
 #endif
 
-    //
-    //	VDR draws subtitle without clearing the old
-    //
-    if (OsdLevel >= OSD_LEVEL_SUBTITLES) {
-	VideoOsdClear();
-	cSoftOsd::Dirty = 1;
-#ifdef OSD_DEBUG
-	dsyslog("[softhddev]%s: subtitle clear\n", __FUNCTION__);
-#endif
-    }
-
     if (!IsTrueColor()) {
 	cBitmap *bitmap;
 	int i;
@@ -472,7 +491,7 @@
 	    // FIXME: reuse argb
 	    free(argb);
 	}
-	cSoftOsd::Dirty = 0;
+	Dirty = 0;
 	return;
     }
 
@@ -496,7 +515,7 @@
 
 	delete pm;
     }
-    cSoftOsd::Dirty = 0;
+    Dirty = 0;
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -580,6 +599,7 @@
     int General;
     int MakePrimary;
     int HideMainMenuEntry;
+    int DetachFromMainMenu;
     int OsdSize;
     int OsdWidth;
     int OsdHeight;
@@ -595,6 +615,7 @@
     int _60HzMode;
     int SoftStartSync;
     int BlackPicture;
+    int ClearOnSwitch;
 
     int Brightness;
     int Contrast;
@@ -630,6 +651,7 @@
     int AudioMaxCompression;
     int AudioStereoDescent;
     int AudioBufferTime;
+    int AudioAutoAES;
 
 #ifdef USE_PIP
     int Pip;
@@ -757,6 +779,8 @@
 	//	suspend
 	//
 	Add(SeparatorItem(tr("Suspend")));
+	Add(new cMenuEditBoolItem(tr("Detach from main menu entry"),
+		&DetachFromMainMenu, trVDR("no"), trVDR("yes")));
 	Add(new cMenuEditBoolItem(tr("Suspend closes video+audio"),
 		&SuspendClose, trVDR("no"), trVDR("yes")));
 	Add(new cMenuEditBoolItem(tr("Suspend stops x11"), &SuspendX11,
@@ -785,6 +809,8 @@
 		trVDR("no"), trVDR("yes")));
 	Add(new cMenuEditBoolItem(tr("Black during channel switch"),
 		&BlackPicture, trVDR("no"), trVDR("yes")));
+	Add(new cMenuEditBoolItem(tr("Clear decoder on channel switch"),
+		&ClearOnSwitch, trVDR("no"), trVDR("yes")));
 
 	Add(new cMenuEditIntItem(tr("Brightness (-1000..1000) (vdpau)"),
 		&Brightness, -1000, 1000, tr("min"), tr("max")));
@@ -872,6 +898,8 @@
 		&AudioStereoDescent, 0, 1000));
 	Add(new cMenuEditIntItem(tr("Audio buffer size (ms)"),
 		&AudioBufferTime, 0, 1000));
+	Add(new cMenuEditBoolItem(tr("Enable automatic AES"), &AudioAutoAES,
+		trVDR("no"), trVDR("yes")));
     }
 #ifdef USE_PIP
     //
@@ -977,6 +1005,7 @@
     General = 0;
     MakePrimary = ConfigMakePrimary;
     HideMainMenuEntry = ConfigHideMainMenuEntry;
+    DetachFromMainMenu = ConfigDetachFromMainMenu;
     //
     //	osd
     //
@@ -1010,6 +1039,7 @@
     _60HzMode = ConfigVideo60HzMode;
     SoftStartSync = ConfigVideoSoftStartSync;
     BlackPicture = ConfigVideoBlackPicture;
+    ClearOnSwitch = ConfigVideoClearOnSwitch;
 
     Brightness = ConfigVideoBrightness;
     Contrast = ConfigVideoContrast;
@@ -1053,6 +1083,7 @@
     AudioMaxCompression = ConfigAudioMaxCompression;
     AudioStereoDescent = ConfigAudioStereoDescent;
     AudioBufferTime = ConfigAudioBufferTime;
+    AudioAutoAES = ConfigAudioAutoAES;
 
 #ifdef USE_PIP
     //
@@ -1089,6 +1120,8 @@
     SetupStore("MakePrimary", ConfigMakePrimary = MakePrimary);
     SetupStore("HideMainMenuEntry", ConfigHideMainMenuEntry =
 	HideMainMenuEntry);
+    SetupStore("DetachFromMainMenu", ConfigDetachFromMainMenu =
+	DetachFromMainMenu);
     switch (OsdSize) {
 	case 0:
 	    OsdWidth = 0;
@@ -1133,6 +1166,7 @@
     VideoSetSoftStartSync(ConfigVideoSoftStartSync);
     SetupStore("BlackPicture", ConfigVideoBlackPicture = BlackPicture);
     VideoSetBlackPicture(ConfigVideoBlackPicture);
+    SetupStore("ClearOnSwitch", ConfigVideoClearOnSwitch = ClearOnSwitch);
 
     SetupStore("Brightness", ConfigVideoBrightness = Brightness);
     VideoSetBrightness(ConfigVideoBrightness);
@@ -1214,6 +1248,8 @@
 	AudioStereoDescent);
     AudioSetStereoDescent(ConfigAudioStereoDescent);
     SetupStore("AudioBufferTime", ConfigAudioBufferTime = AudioBufferTime);
+    SetupStore("AudioAutoAES", ConfigAudioAutoAES = AudioAutoAES);
+    AudioSetAutoAES(ConfigAudioAutoAES);
 
 #ifdef USE_PIP
     SetupStore("pip.X", ConfigPipX = PipX);
@@ -1746,7 +1782,12 @@
     Clear();				// clear the menu
 
     SetHasHotkeys();
-    Add(new cOsdItem(hk(tr("Suspend SoftHdDevice")), osUser1));
+
+    if (ConfigDetachFromMainMenu) {
+	Add(new cOsdItem(hk(tr("Detach SoftHdDevice")), osUser1));
+    } else {
+	Add(new cOsdItem(hk(tr("Suspend SoftHdDevice")), osUser1));
+    }
 #ifdef USE_PIP
     if (PipReceiver) {
 	Add(new cOsdItem(hk(tr("PIP toggle on/off: off")), osUser2));
@@ -1916,6 +1957,7 @@
 	    break;
 	case 108:
 	    DelPip();
+	    PipChannelNr = 0;
 	    break;
 #endif
 
@@ -1993,9 +2035,14 @@
 	    if (SuspendMode == NOT_SUSPENDED && !cSoftHdControl::Player) {
 		cControl::Launch(new cSoftHdControl);
 		cControl::Attach();
-		Suspend(ConfigSuspendClose, ConfigSuspendClose,
-		    ConfigSuspendX11);
-		SuspendMode = SUSPEND_NORMAL;
+		if (ConfigDetachFromMainMenu) {
+		    Suspend(1, 1, 0);
+		    SuspendMode = SUSPEND_DETACHED;
+		} else {
+		    Suspend(ConfigSuspendClose, ConfigSuspendClose,
+			ConfigSuspendX11);
+		    SuspendMode = SUSPEND_NORMAL;
+		}
 		if (ShutdownHandler.GetUserInactiveTime()) {
 		    dsyslog("[softhddev]%s: set user inactive\n",
 			__FUNCTION__);
@@ -2021,6 +2068,7 @@
 	    return osEnd;
 	case osUser8:
 	    DelPip();
+	    PipChannelNr = 0;
 	    return osEnd;
 #endif
 	default:
@@ -2043,7 +2091,11 @@
     virtual bool HasDecoder(void) const;
     virtual bool CanReplay(void) const;
     virtual bool SetPlayMode(ePlayMode);
+#if APIVERSNUM >= 20103
+    virtual void TrickSpeed(int, bool);
+#else
     virtual void TrickSpeed(int);
+#endif
     virtual void Clear(void);
     virtual void Play(void);
     virtual void Freeze(void);
@@ -2231,13 +2283,23 @@
 **	times.
 **
 **	@param speed	trick speed
+**	@param forward	flag forward direction
 */
+#if APIVERSNUM >= 20103
+void cSoftHdDevice::TrickSpeed(int speed, bool forward)
+{
+    dsyslog("[softhddev]%s: %d $d\n", __FUNCTION__, speed, forward);
+
+    ::TrickSpeed(speed);
+}
+#else
 void cSoftHdDevice::TrickSpeed(int speed)
 {
     dsyslog("[softhddev]%s: %d\n", __FUNCTION__, speed);
 
     ::TrickSpeed(speed);
 }
+#endif
 
 /**
 **	Clears all video and audio data from the device.
@@ -2542,8 +2604,8 @@
 void cSoftHdDevice::ScaleVideo(const cRect & rect)
 {
 #ifdef OSD_DEBUG
-    dsyslog("[softhddev]%s: %dx%d%+d%+d\n", __FUNCTION__, VidWinRect.Width(),
-	VidWinRect.Height(), VidWinRect.X(), VidWinRect.Y());
+    dsyslog("[softhddev]%s: %dx%d%+d%+d\n", __FUNCTION__, rect.Width(),
+	rect.Height(), rect.X(), rect.Y());
 #endif
     ::ScaleVideo(rect.X(), rect.Y(), rect.Width(), rect.Height());
 }
@@ -2803,6 +2865,10 @@
 	ConfigHideMainMenuEntry = atoi(value);
 	return true;
     }
+    if (!strcasecmp(name, "DetachFromMainMenu")) {
+	ConfigDetachFromMainMenu = atoi(value);
+	return true;
+    }
     if (!strcasecmp(name, "Osd.Width")) {
 	ConfigOsdWidth = atoi(value);
 	VideoSetOsdSize(ConfigOsdWidth, ConfigOsdHeight);
@@ -2852,6 +2918,10 @@
 	VideoSetBlackPicture(ConfigVideoBlackPicture = atoi(value));
 	return true;
     }
+    if (!strcasecmp(name, "ClearOnSwitch")) {
+	ConfigVideoClearOnSwitch = atoi(value);
+	return true;
+    }
     if (!strcasecmp(name, "Brightness")) {
 	VideoSetBrightness(ConfigVideoBrightness = atoi(value));
 	return true;
@@ -2998,6 +3068,11 @@
 	ConfigAudioBufferTime = atoi(value);
 	return true;
     }
+    if (!strcasecmp(name, "AudioAutoAES")) {
+	ConfigAudioAutoAES = atoi(value);
+	AudioSetAutoAES(ConfigAudioAutoAES);
+	return true;
+    }
 #ifdef USE_PIP
     if (!strcasecmp(name, "pip.X")) {
 	ConfigPipX = atoi(value);
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/softhddevice.h git/softhddevice.h
--- vdr-plugin-softhddevice-0.6.1rc1/softhddevice.h	2013-09-30 20:54:27.000000000 +0200
+++ git/softhddevice.h	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file softhddevice.h	@brief software HD device plugin header file.
 ///
-///	Copyright (c) 2011 by Johns.  All Rights Reserved.
+///	Copyright (c) 2011, 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,5 +17,5 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: 3bc44809950ec019529638cad9223a85d4ab5576 $
 //////////////////////////////////////////////////////////////////////////////
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/softhddevice_service.h git/softhddevice_service.h
--- vdr-plugin-softhddevice-0.6.1rc1/softhddevice_service.h	2013-09-30 20:54:27.000000000 +0200
+++ git/softhddevice_service.h	2014-06-25 20:06:27.000000000 +0200
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: c7c2d5e8b724515d7c767668aab717b27f4e4068 $
 //////////////////////////////////////////////////////////////////////////////
 
 #pragma once
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/Todo git/Todo
--- vdr-plugin-softhddevice-0.6.1rc1/Todo	2013-09-30 20:54:27.000000000 +0200
+++ git/Todo	2014-06-25 20:06:27.000000000 +0200
@@ -45,6 +45,7 @@
     still-picture of PES recordings should use VideoMpegEnqueue.
     convert PIX_FMT_... PixelFormat to new names AV_PIX_FMT_..., AVPixelFormat.
     atmo service support 3D grab
+    no warnings during still picture
 
 vdpau:
     software deinterlace path not working.
@@ -127,6 +128,7 @@
     svdrp prim: support plugin names for device numbers.
     Workaround exists: hangup PipVideoStream -> Vdpau_get_format -> xcb -> poll
 	+ lock DecoderLockMutex
+    check compiletime and runtime ffmpeg/libav version during init.
 
 future features (not planed for 1.0 - 1.5)
 
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/video.c git/video.c
--- vdr-plugin-softhddevice-0.6.1rc1/video.c	2013-09-30 20:54:27.000000000 +0200
+++ git/video.c	2014-06-25 20:06:27.000000000 +0200
@@ -1,7 +1,7 @@
 ///
 ///	@file video.c	@brief Video module
 ///
-///	Copyright (c) 2009 - 2013 by Johns.  All Rights Reserved.
+///	Copyright (c) 2009 - 2014 by Johns.  All Rights Reserved.
 ///
 ///	Contributor(s):
 ///
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: a5b3a5aac9c75598bd5f926ac3ceab6e03cbc2bd $
 //////////////////////////////////////////////////////////////////////////////
 
 ///
@@ -46,7 +46,7 @@
 #define USE_DOUBLEBUFFER		///< use GLX double buffers
 //#define USE_VAAPI				///< enable vaapi support
 //#define USE_VDPAU				///< enable vdpau support
-#define noUSE_BITMAP			///< use vdpau bitmap surface
+//#define USE_BITMAP			///< use vdpau bitmap surface
 //#define AV_INFO				///< log a/v sync informations
 #ifndef AV_INFO_TIME
 #define AV_INFO_TIME (50 * 60)		///< a/v info every minute
@@ -64,13 +64,12 @@
 #include <stdint.h>
 #include <string.h>
 #include <unistd.h>
+#include <math.h>
 
 #include <libintl.h>
 #define _(str) gettext(str)		///< gettext shortcut
 #define _N(str) str			///< gettext_noop shortcut
 
-#include <alsa/iatomic.h>		// portable atomic_t
-
 #ifdef USE_VIDEO_THREAD
 #ifndef __USE_GNU
 #define __USE_GNU
@@ -135,6 +134,9 @@
 
 #ifdef USE_VAAPI
 #include <va/va_x11.h>
+#if VA_CHECK_VERSION(0,33,99)
+#include <va/va_vpp.h>
+#endif
 #ifdef USE_GLX
 #include <va/va_glx.h>
 #endif
@@ -175,6 +177,7 @@
 #define FFMPEG_BUG1_WORKAROUND		///< get_format bug workaround
 #endif
 
+#include "iatomic.h"			// portable atomic_t
 #include "misc.h"
 #include "video.h"
 #include "audio.h"
@@ -912,13 +915,13 @@
     // FIXME: if not; use zero buffer
     // FIXME: if not; use dirty area
 
-    texbuf = calloc(OsdWidth * OsdHeight, 4);
-
     // set glx context
     if (!glXMakeCurrent(XlibDisplay, VideoWindow, GlxContext)) {
 	Error(_("video/glx: can't make glx context current\n"));
 	return;
     }
+
+    texbuf = calloc(OsdWidth * OsdHeight, 4);
     GlxUploadOsdTexture(0, 0, OsdWidth, OsdHeight, texbuf);
     glXMakeCurrent(XlibDisplay, None, NULL);
 
@@ -1454,6 +1457,10 @@
 static VASubpictureID VaOsdSubpicture = VA_INVALID_ID;	///< osd VA-API subpicture
 static char VaapiUnscaledOsd;		///< unscaled osd supported
 
+#if VA_CHECK_VERSION(0,33,99)
+static char VaapiVideoProcessing;	///< supports video processing
+#endif
+
     /// VA-API decoder typedef
 typedef struct _vaapi_decoder_ VaapiDecoder;
 
@@ -2364,6 +2371,28 @@
     Vaapi1080i();
 #endif
 
+#if VA_CHECK_VERSION(0,33,99)
+    //
+    //	check vpp support
+    //
+    if (1) {
+	VAEntrypoint entrypoints[vaMaxNumEntrypoints(VaDisplay)];
+	int entrypoint_n;
+	int i;
+
+	vaQueryConfigEntrypoints(VaDisplay, VAProfileNone, entrypoints,
+	    &entrypoint_n);
+
+	VaapiVideoProcessing = 0;
+	for (i = 0; i < entrypoint_n; i++) {
+	    if (entrypoints[i] == VAEntrypointVideoProc) {
+		Info("video/vaapi: supports video processing\n");
+		VaapiVideoProcessing = 1;
+		break;
+	    }
+	}
+    }
+#endif
     return 1;
 }
 
@@ -2587,6 +2616,126 @@
 }
 
 ///
+///	Configure VA-API for new video format.
+///
+///	@param decoder	VA-API decoder
+///
+static void VaapiSetupVideoProcessing(VaapiDecoder * decoder)
+{
+#if VA_CHECK_VERSION(0,33,99)
+    VAProcFilterType filtertypes[VAProcFilterCount];
+    unsigned filtertype_n;
+    unsigned u;
+    unsigned v;
+    VAProcFilterCap denoise_caps[1];
+    unsigned denoise_cap_n;
+    VAProcFilterCapDeinterlacing deinterlacing_caps[VAProcDeinterlacingCount];
+    unsigned deinterlacing_cap_n;
+    VABufferID denoise_filter;
+    VABufferID deint_filter;
+    VABufferID sharpen_filter;
+    VABufferID color_filter;
+    VABufferID filters[VAProcFilterCount];
+    unsigned filter_n;
+
+    if (!VaapiVideoProcessing) {
+	return;
+    }
+    //
+    //	display and filter infos.
+    //
+    filtertype_n = VAProcFilterCount;	// API break this must be done
+    vaQueryVideoProcFilters(VaDisplay, decoder->VaapiContext->context_id,
+	filtertypes, &filtertype_n);
+    for (u = 0; u < filtertype_n; ++u) {
+	switch (filtertypes[u]) {
+	    case VAProcFilterNoiseReduction:
+		Info("video/vaapi: noise reduction supported\n");
+
+		denoise_cap_n = 1;
+		vaQueryVideoProcFilterCaps(VaDisplay,
+		    decoder->VaapiContext->context_id,
+		    VAProcFilterNoiseReduction, denoise_caps, &denoise_cap_n);
+		if (denoise_cap_n) {
+		    Info("video/vaapi: %.2f - %.2f ++ %.2f = %.2f\n",
+			denoise_caps->range.min_value,
+			denoise_caps->range.max_value,
+			denoise_caps->range.step,
+			denoise_caps->range.default_value);
+		}
+		break;
+	    case VAProcFilterDeinterlacing:
+		Info("video/vaapi: deinterlacing supported\n");
+
+		deinterlacing_cap_n = VAProcDeinterlacingCount;
+		vaQueryVideoProcFilterCaps(VaDisplay,
+		    decoder->VaapiContext->context_id,
+		    VAProcFilterDeinterlacing, deinterlacing_caps,
+		    &deinterlacing_cap_n);
+		for (v = 0; v < deinterlacing_cap_n; ++v) {
+		    switch (deinterlacing_caps[v].type) {
+			case VAProcDeinterlacingBob:
+			    Info("video/vaapi: bob deinterlace supported\n");
+			    break;
+			case VAProcDeinterlacingWeave:
+			    Info("video/vaapi: weave deinterlace supported\n");
+			    break;
+			case VAProcDeinterlacingMotionAdaptive:
+			    Info("video/vaapi: motion adaptive deinterlace supported\n");
+			    break;
+			case VAProcDeinterlacingMotionCompensated:
+			    Info("video/vaapi: motion compensated deinterlace supported\n");
+			    break;
+			default:
+			    Info("video/vaapi: unsupported deinterlace #%02x\n", deinterlacing_caps[v].type);
+			    break;
+		    }
+		}
+		break;
+	    case VAProcFilterSharpening:
+		Info("video/vaapi: sharpening supported\n");
+		break;
+	    case VAProcFilterColorBalance:
+		Info("video/vaapi: color balance supported\n");
+		break;
+	    default:
+		Info("video/vaapi: unsupported filter #%02x\n",
+		    filtertypes[u]);
+		break;
+	}
+    }
+
+    //
+    //	create pipeline filters
+    //
+    filter_n = 0;
+
+    filtertype_n = VAProcFilterCount;
+    vaQueryVideoProcFilters(VaDisplay, decoder->VaapiContext->context_id,
+	filtertypes, &filtertype_n);
+    for (u = 0; u < filtertype_n; ++u) {
+	switch (filtertypes[u]) {
+	    case VAProcFilterNoiseReduction:
+		break;
+	    case VAProcFilterDeinterlacing:
+		break;
+	    case VAProcFilterSharpening:
+		break;
+	    case VAProcFilterColorBalance:
+		break;
+	    default:
+		break;
+	}
+    }
+
+    //
+    //	query pipeline caps
+    //
+
+#endif
+}
+
+///
 ///	Get a free surface.  Called from ffmpeg.
 ///
 ///	@param decoder		VA-API decoder
@@ -2627,6 +2776,7 @@
 		vaErrorStr(status));
 	}
 	// FIXME: too late to switch to software rending on failures
+	VaapiSetupVideoProcessing(decoder);
     }
 #else
     (void)video_ctx;
@@ -2859,6 +3009,7 @@
 	    Error(_("codec: can't create context '%s'\n"), vaErrorStr(status));
 	    goto slow_path;
 	}
+	VaapiSetupVideoProcessing(decoder);
     }
 #endif
 
@@ -3491,7 +3642,7 @@
 		VA_FRAME_PICTURE)) != VA_STATUS_SUCCESS) {
 	Error(_("video/vaapi: vaPutSurface failed %d\n"), status);
     }
-    clock_gettime(CLOCK_REALTIME, &decoder->FrameTime);
+    clock_gettime(CLOCK_MONOTONIC, &decoder->FrameTime);
 
     put1 = GetMsTicks();
     if (put1 - sync > 2000) {
@@ -4731,7 +4882,7 @@
 	    put2 = put1;
 #endif
 	}
-	clock_gettime(CLOCK_REALTIME, &nowtime);
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
 	// FIXME: 31 only correct for 50Hz
 	if ((nowtime.tv_sec - decoder->FrameTime.tv_sec)
 	    * 1000 * 1000 * 1000 + (nowtime.tv_nsec -
@@ -4979,7 +5130,10 @@
 		_("video: decoder buffer empty, "
 		    "duping frame (%d/%d) %d v-buf\n"), decoder->FramesDuped,
 		decoder->FrameCounter, VideoGetBuffers(decoder->Stream));
-	    if (decoder->Closing < -300) {
+	    // some time no new picture or black video configured
+	    if (decoder->Closing < -300 || (VideoShowBlackPicture
+		    && decoder->Closing)) {
+		// clear ring buffer to trigger black picture
 		atomic_set(&decoder->SurfacesFilled, 0);
 	    }
 	}
@@ -5159,7 +5313,7 @@
 	}
     }
 
-    clock_gettime(CLOCK_REALTIME, &nowtime);
+    clock_gettime(CLOCK_MONOTONIC, &nowtime);
     // time for one frame over?
     if ((nowtime.tv_sec - decoder->FrameTime.tv_sec)
 	* 1000 * 1000 * 1000 + (nowtime.tv_nsec - decoder->FrameTime.tv_nsec) <
@@ -5341,7 +5495,7 @@
 
     VaapiUnscaledOsd = 0;
     if (flags[u] & VA_SUBPICTURE_DESTINATION_IS_SCREEN_COORD) {
-	Info(_("video/vaapi: vaapi supports unscaled osd\n"));
+	Info(_("video/vaapi: supports unscaled osd\n"));
 	VaapiUnscaledOsd = 1;
     }
     //VaapiUnscaledOsd = 0;
@@ -8021,7 +8175,7 @@
 	status =
 	    VdpauOutputSurfaceRenderBitmapSurface(VdpauSurfacesRb
 	    [VdpauSurfaceIndex], &output_double_rect,
-	    VdpauOsdOutputSurface[!VdpauOsdSurfaceIndex], &source_rect, NULL,
+	    VdpauOsdBitmapSurface[!VdpauOsdSurfaceIndex], &source_rect, NULL,
 	    VideoTransparentOsd ? &blend_state : NULL,
 	    VDP_OUTPUT_SURFACE_RENDER_ROTATE_0);
 	if (status != VDP_STATUS_OK) {
@@ -8250,15 +8404,29 @@
 	output_rect.y1 = decoder->VideoHeight;
     }
 
+    // FIXME: double buffered osd disabled
+    // VdpauOsdSurfaceIndex always 0 and only 0 valid
+#ifdef USE_BITMAP
+    status =
+	VdpauOutputSurfaceRenderBitmapSurface(VdpauSurfacesRb
+	[VdpauSurfaceIndex], &output_rect,
+	VdpauOsdBitmapSurface[VdpauOsdSurfaceIndex], &source_rect, NULL, NULL,
+	VDP_OUTPUT_SURFACE_RENDER_ROTATE_0);
+    if (status != VDP_STATUS_OK) {
+	Error(_("video/vdpau: can't render output surface: %s\n"),
+	    VdpauGetErrorString(status));
+    }
+#else
     status =
 	VdpauOutputSurfaceRenderOutputSurface(VdpauSurfacesRb
 	[VdpauSurfaceIndex], &output_rect,
-	VdpauOsdOutputSurface[!VdpauOsdSurfaceIndex], &source_rect, NULL, NULL,
+	VdpauOsdOutputSurface[VdpauOsdSurfaceIndex], &source_rect, NULL, NULL,
 	VDP_OUTPUT_SURFACE_RENDER_ROTATE_0);
     if (status != VDP_STATUS_OK) {
 	Error(_("video/vdpau: can't render output surface: %s\n"),
 	    VdpauGetErrorString(status));
     }
+#endif
 }
 
 ///
@@ -8382,7 +8550,7 @@
 	    VdpauGetErrorString(status));
     }
     // FIXME: CLOCK_MONOTONIC_RAW
-    clock_gettime(CLOCK_REALTIME, &VdpauFrameTime);
+    clock_gettime(CLOCK_MONOTONIC, &VdpauFrameTime);
     for (i = 0; i < VdpauDecoderN; ++i) {
 	// remember time of last shown surface
 	VdpauDecoders[i]->FrameTime = VdpauFrameTime;
@@ -8609,7 +8777,10 @@
 		_("video: decoder buffer empty, "
 		    "duping frame (%d/%d) %d v-buf\n"), decoder->FramesDuped,
 		decoder->FrameCounter, VideoGetBuffers(decoder->Stream));
-	    if (decoder->Closing < -300) {
+	    // some time no new picture or black video configured
+	    if (decoder->Closing < -300 || (VideoShowBlackPicture
+		    && decoder->Closing)) {
+		// clear ring buffer to trigger black picture
 		atomic_set(&decoder->SurfacesFilled, 0);
 	    }
 	}
@@ -8884,7 +9055,7 @@
 	usleep(5 * 1000);
     }
 
-    clock_gettime(CLOCK_REALTIME, &nowtime);
+    clock_gettime(CLOCK_MONOTONIC, &nowtime);
     // time for one frame over?
     if ((nowtime.tv_sec - VdpauFrameTime.tv_sec) * 1000 * 1000 * 1000 +
 	(nowtime.tv_nsec - VdpauFrameTime.tv_nsec) < 15 * 1000 * 1000) {
@@ -8893,7 +9064,7 @@
 
     if (VdpauPreemption) {		// display preempted
 	if (VdpauPreemptionRecover()) {
-	    clock_gettime(CLOCK_REALTIME, &VdpauFrameTime);
+	    clock_gettime(CLOCK_MONOTONIC, &VdpauFrameTime);
 	    return;
 	}
     }
@@ -8925,7 +9096,7 @@
 static void VdpauSetOutputPosition(VdpauDecoder * decoder, int x, int y,
     int width, int height)
 {
-    Debug(3, "video/vdapu: output %dx%d%+d%+d\n", width, height, x, y);
+    Debug(3, "video/vdpau: output %dx%d%+d%+d\n", width, height, x, y);
 
     decoder->VideoX = x;
     decoder->VideoY = y;
@@ -9520,7 +9691,7 @@
 //----------------------------------------------------------------------------
 
 /// C callback feed key press
-extern void FeedKeyPress(const char *, const char *, int, int);
+extern void FeedKeyPress(const char *, const char *, int, int, const char *);
 
 ///
 ///	Handle XLib I/O Errors.
@@ -9564,6 +9735,7 @@
     KeySym keysym;
     const char *keynam;
     char buf[64];
+    char letter[64];
     uint32_t values[1];
 
     VideoThreadLock();
@@ -9574,7 +9746,7 @@
 	    Debug(3, "video/event: ClientMessage\n");
 	    if (event.xclient.data.l[0] == (long)WmDeleteWindowAtom) {
 		Debug(3, "video/event: wm-delete-message\n");
-		FeedKeyPress("XKeySym", "Close", 0, 0);
+		FeedKeyPress("XKeySym", "Close", 0, 0, NULL);
 	    }
 	    break;
 
@@ -9603,7 +9775,7 @@
 	    break;
 	case KeyPress:
 	    VideoThreadLock();
-	    XLookupString(&event.xkey, buf, sizeof(buf), &keysym, NULL);
+	    XLookupString(&event.xkey, letter, sizeof(letter), &keysym, NULL);
 	    VideoThreadUnlock();
 	    if (keysym == NoSymbol) {
 		Warning(_("video/event: No symbol for %d\n"),
@@ -9626,7 +9798,7 @@
 		strncat(buf, keynam, sizeof(buf) - 10);
 		keynam = buf;
 	    }
-	    FeedKeyPress("XKeySym", keynam, 0, 0);
+	    FeedKeyPress("XKeySym", keynam, 0, 0, letter);
 	    break;
 	case KeyRelease:
 	    break;
@@ -11283,7 +11455,8 @@
     const char *x, __attribute__ ((unused))
     const char *y, __attribute__ ((unused))
     int a, __attribute__ ((unused))
-    int b)
+    int b, __attribute__ ((unused))
+    const char *s)
 {
 }
 
@@ -11301,7 +11474,7 @@
 #ifdef GIT_REV
 	"(GIT-" GIT_REV ")"
 #endif
-	",\n\t(c) 2009 - 2013 by Johns\n"
+	",\n\t(c) 2009 - 2014 by Johns\n"
 	"\tLicense AGPLv3: GNU Affero General Public License version 3\n");
 }
 
diff -Naur vdr-plugin-softhddevice-0.6.1rc1/video.h git/video.h
--- vdr-plugin-softhddevice-0.6.1rc1/video.h	2013-09-30 20:54:27.000000000 +0200
+++ git/video.h	2014-06-25 20:06:27.000000000 +0200
@@ -17,7 +17,7 @@
 ///	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ///	GNU Affero General Public License for more details.
 ///
-///	$Id$
+///	$Id: fa3e44f3620c4cdae2b0512b13c298fc71ffff0b $
 //////////////////////////////////////////////////////////////////////////////
 
 /// @addtogroup Video
